"""
Population Dynamics System for SimuLife
Handles population pressure, resource scarcity, carrying capacity, and survival dynamics.
"""

import random
import math
from typing import Dict, List, Any, Tuple, Optional
from dataclasses import dataclass


@dataclass
class PopulationMetrics:
    """Tracks population statistics and health."""
    total_population: int = 0
    birth_rate: float = 0.0
    death_rate: float = 0.0
    population_growth_rate: float = 0.0
    carrying_capacity: int = 100
    resource_pressure: float = 0.0
    population_pressure: float = 0.0
    avg_age: float = 0.0
    gender_ratio: float = 0.5  # Female ratio
    generation_distribution: Dict[int, int] = None


class PopulationDynamicsSystem:
    """
    Manages population dynamics, resource competition, and survival pressures.
    """
    
    def __init__(self, carrying_capacity: int = 100):
        self.carrying_capacity = carrying_capacity
        self.population_history = []
        self.resource_scarcity_events = []
        self.migration_events = []
        
        # Population pressure thresholds
        self.pressure_thresholds = {
            "low": 0.3,      # Below 30% of carrying capacity
            "moderate": 0.6,  # 30-60% of capacity
            "high": 0.8,     # 60-80% of capacity  
            "critical": 1.0   # 80%+ of capacity
        }
        
    def calculate_population_metrics(self, agents: List[Any]) -> PopulationMetrics:
        """Calculate comprehensive population statistics."""
        if not agents:
            return PopulationMetrics()
            
        alive_agents = [a for a in agents if getattr(a, 'is_alive', True)]
        total_pop = len(alive_agents)
        
        # Basic demographics
        ages = [a.age for a in alive_agents]
        avg_age = sum(ages) / len(ages) if ages else 0
        
        # Gender distribution
        genders = [getattr(a, 'gender', 'unknown') for a in alive_agents]
        female_count = genders.count('female')
        gender_ratio = female_count / total_pop if total_pop > 0 else 0.5
        
        # Generation distribution
        generations = [getattr(a, 'generation', 1) for a in alive_agents]
        gen_dist = {}
        for gen in generations:
            gen_dist[gen] = gen_dist.get(gen, 0) + 1
            
        # Calculate pressures
        pop_pressure = total_pop / self.carrying_capacity
        
        metrics = PopulationMetrics(
            total_population=total_pop,
            population_pressure=pop_pressure,
            avg_age=avg_age,
            gender_ratio=gender_ratio,
            generation_distribution=gen_dist,
            carrying_capacity=self.carrying_capacity
        )
        
        return metrics
    
    def calculate_resource_pressure(self, world_resources: Dict[str, float], 
                                  population_size: int) -> float:
        """
        Calculate resource pressure based on population vs available resources.
        
        Returns:
            Float between 0.0 (abundant resources) and 1.0+ (severe scarcity)
        """
        if population_size == 0:
            return 0.0
            
        # Calculate resource demand per person
        base_demand_per_person = 1.0
        total_demand = population_size * base_demand_per_person
        
        # Calculate available resources
        essential_resources = ['food', 'water', 'shelter_materials', 'medicine']
        available_resources = 0.0
        
        for resource in essential_resources:
            available_resources += world_resources.get(resource, 0.0)
            
        # Resource pressure calculation
        if available_resources <= 0:
            return 1.5  # Severe scarcity
        
        pressure = total_demand / available_resources
        return min(pressure, 2.0)  # Cap at 2.0 for extreme scarcity
    
    def apply_population_pressure_effects(self, agents: List[Any], 
                                        resource_pressure: float,
                                        population_pressure: float) -> List[Dict[str, Any]]:
        """
        Apply effects of population and resource pressure on agents.
        
        Returns:
            List of events generated by population pressure
        """
        events = []
        
        # Determine pressure level
        total_pressure = (resource_pressure + population_pressure) / 2
        
        if total_pressure < self.pressure_thresholds["low"]:
            pressure_level = "abundant"
        elif total_pressure < self.pressure_thresholds["moderate"]:
            pressure_level = "stable"
        elif total_pressure < self.pressure_thresholds["high"]:
            pressure_level = "strained"
        else:
            pressure_level = "critical"
        
        # Apply pressure effects
        if pressure_level == "abundant":
            # Boost fertility and happiness
            for agent in agents:
                if hasattr(agent, 'fertility'):
                    agent.fertility = min(1.0, agent.fertility + 0.05)
                if hasattr(agent, 'life_satisfaction'):
                    agent.life_satisfaction = min(1.0, agent.life_satisfaction + 0.1)
                    
        elif pressure_level == "strained":
            # Reduce fertility, increase stress
            for agent in agents:
                if hasattr(agent, 'fertility'):
                    agent.fertility = max(0.1, agent.fertility - 0.1)
                if hasattr(agent, 'life_satisfaction'):
                    agent.life_satisfaction = max(0.0, agent.life_satisfaction - 0.2)
                    
            events.append({
                "type": "resource_competition",
                "description": f"Population pressure leads to increased competition for resources",
                "participants": [a.name for a in agents[:3]],  # First few agents affected
                "location": "community",
                "importance": 0.7
            })
            
        elif pressure_level == "critical":
            # Severe effects: reduced fertility, health issues, potential conflicts
            for agent in agents:
                if hasattr(agent, 'fertility'):
                    agent.fertility = max(0.05, agent.fertility - 0.2)
                if hasattr(agent, 'health'):
                    agent.health = max(0.3, agent.health - 0.1)
                if hasattr(agent, 'life_satisfaction'):
                    agent.life_satisfaction = max(0.0, agent.life_satisfaction - 0.3)
                    
            # Generate crisis events
            events.extend([
                {
                    "type": "resource_crisis",
                    "description": "Severe resource scarcity threatens the community's survival",
                    "participants": [a.name for a in agents],
                    "location": "community",
                    "importance": 0.9
                },
                {
                    "type": "population_stress", 
                    "description": "Overcrowding leads to social tensions and health problems",
                    "participants": [a.name for a in random.sample(agents, min(5, len(agents)))],
                    "location": "community",
                    "importance": 0.8
                }
            ])
            
        return events
    
    def check_carrying_capacity_exceeded(self, agents: List[Any]) -> Tuple[bool, List[Dict[str, Any]]]:
        """
        Check if population has exceeded carrying capacity and generate appropriate events.
        
        Returns:
            Tuple of (capacity_exceeded, events_generated)
        """
        alive_agents = [a for a in agents if getattr(a, 'is_alive', True)]
        population = len(alive_agents)
        exceeded = population > self.carrying_capacity
        events = []
        
        if exceeded:
            excess_population = population - self.carrying_capacity
            
            # Generate migration pressure
            if random.random() < 0.3:  # 30% chance of migration event
                migrants = random.sample(alive_agents, min(excess_population // 2, 3))
                events.append({
                    "type": "forced_migration",
                    "description": f"{len(migrants)} individuals forced to leave due to overcrowding",
                    "participants": [m.name for m in migrants],
                    "location": "community_edge",
                    "importance": 0.7
                })
                
                # Actually remove migrants (mark for removal)
                for migrant in migrants:
                    migrant.location = "migrated_away"
                    migrant.is_alive = False  # Remove from active population
            
            # Generate resource competition event
            events.append({
                "type": "overcrowding_crisis",
                "description": f"Population of {population} exceeds carrying capacity of {self.carrying_capacity}",
                "participants": [a.name for a in random.sample(alive_agents, min(5, len(alive_agents)))],
                "location": "community",
                "importance": 0.8
            })
            
        return exceeded, events
    
    def natural_population_regulation(self, agents: List[Any], 
                                    current_day: int) -> List[Dict[str, Any]]:
        """
        Apply natural population regulation mechanisms (disease, aging, accidents).
        
        Returns:
            List of mortality/morbidity events
        """
        events = []
        alive_agents = [a for a in agents if getattr(a, 'is_alive', True)]
        population = len(alive_agents)
        
        # Population-dependent mortality rate
        base_mortality = 0.001  # 0.1% daily base mortality
        if population > self.carrying_capacity * 0.8:
            # Increased mortality due to overcrowding
            overcrowding_factor = (population / self.carrying_capacity) ** 2
            mortality_rate = base_mortality * overcrowding_factor
        else:
            mortality_rate = base_mortality
            
        # Apply mortality
        for agent in alive_agents:
            # Age-based mortality
            age_factor = 1.0
            if agent.age > 60:
                age_factor = 1.5 + (agent.age - 60) * 0.1
            elif agent.age < 1:
                age_factor = 2.0  # High infant mortality
                
            # Health-based mortality
            health_factor = 2.0 - getattr(agent, 'health', 1.0)
            
            final_mortality = mortality_rate * age_factor * health_factor
            
            if random.random() < final_mortality:
                agent.is_alive = False
                cause = self._determine_death_cause(agent, population > self.carrying_capacity)
                
                events.append({
                    "type": "natural_death",
                    "description": f"{agent.name} died from {cause}",
                    "participants": [agent.name],
                    "location": agent.location,
                    "importance": 0.6
                })
                
        return events
    
    def _determine_death_cause(self, agent: Any, overcrowded: bool) -> str:
        """Determine realistic cause of death based on circumstances."""
        if agent.age < 1:
            return random.choice(["infant_complications", "malnutrition", "disease"])
        elif agent.age > 70:
            return random.choice(["old_age", "heart_failure", "illness"])
        elif overcrowded:
            return random.choice(["disease_outbreak", "malnutrition", "resource_conflict", "stress"])
        else:
            return random.choice(["accident", "illness", "natural_causes"])
    
    def get_population_status_summary(self, agents: List[Any]) -> str:
        """Get a human-readable summary of population status."""
        metrics = self.calculate_population_metrics(agents)
        
        if metrics.population_pressure < 0.3:
            status = "thriving with abundant resources"
        elif metrics.population_pressure < 0.6:
            status = "stable and sustainable"
        elif metrics.population_pressure < 0.8:
            status = "experiencing some resource strain"
        else:
            status = "facing critical overpopulation pressure"
            
        return f"Population of {metrics.total_population} is {status} (capacity: {self.carrying_capacity})" 